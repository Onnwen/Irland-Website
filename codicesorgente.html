<meta charset="UTF-8">
<!DOCTYPE html>
<html>
	<link href="prism.css" rel="stylesheet" />
	<head>
		<title>G.D.V | Codice sorgente</title>
	</head>

	<body style="padding: 50px; max-width: 1500px;">
		<script src="prism.js"></script>
		<h1 style="margin-top: 50px">Codice sorgente</h1>

		<fieldset style="width:325px">
			<legend><h2 style="font-size: 20px">Scarica progetto</h2></legend>
			<a href="Progetto/GiocoDellaVita_Xcode.zip" download>↓ Scarica progetto Xcode</a>
			<br/>
			<a href="Progetto/GiocoDellaVita_CodeBlocks.zip" download>↓ Scarica progetto Code::Block</a>
		</fieldset>

		<br/>
		<br/>

		<fieldset style="width:325px">
			<legend><h2 style="font-size: 20px">Indice</h2></legend>
			<ul>
				<h3 style="margin: 10px">FILE MAIN</h3>
				<li><a href="#main.cpp">main.cpp</a></li>
				<br/>

				<h3 style="margin: 10px">FILE DI INTESTAZIONE</h3>
				<li><a href="#inputFunctions.hpp">inputFunctions.hpp</a></li>
				<li><a href="#outputFunctions.hpp">outputFunctions.hpp</a></li>
				<li><a href="#languageGestion.hpp">languageGestion.hpp</a></li>
				<li><a href="#systemFunctions.hpp">systemFunctions.hpp</a></li>
				<li><a href="#automaticGenerationFunctions.hpp">automaticGenerationFunctions.hpp</a></li>
				<li><a href="#lifeAndWorldGestion.hpp">lifeAndWorldGestion.hpp</a></li>
				<br/>

				<h3 style="margin: 10px">FILE FUNZIONI</h3>
				<li><a href="#inputFunctions.cpp">inputFunctions.cpp</a></li>
				<li><a href="#outputFunctions.cpp">outputFunctions.cpp</a></li>
				<li><a href="#languageGestion.cpp">languageGestion.cpp</a></li>
				<li><a href="#systemFunctions.cpp">systemFunctions.cpp</a></li>
				<li><a href="#automaticGenerationFunctions.cpp">automaticGenerationFunctions.cpp</a></li>
				<li><a href="#lifeAndWorldGestion.cpp">lifeAndWorldGestion.cpp</a></li>
			</ul>
		</fieldset>

		<br/>
		<a style="color: black;" class="white" href="giocoDellaVita.html">← Torna indietro</a>
		<br/>
		<br/>
		<br/>

		<a name="main.cpp"></a>
		<h3>
			MAIN.CPP
		</h3>

		<pre>
			<code class="language-cpp">
#include "iostream"
#include "ctime"

#include "inputFunctions.hpp"
#include "outputFunctions.hpp"
#include "languageGestion.hpp"
#include "systemFunctions.hpp"
#include "automaticGenerationFunctions.hpp"
#include "lifeAndWorldGestion.hpp"

using namespace std;

int main() {
    bool world[100][100];
    bool gM;
    int gameSettings[7]; // 0 = Tempo di pausa, 1 = Dimensioni mondo, 2 = Gamemode, 3 = Pattern (solo in gamemode 0), 4 = Carattere di vita, 5 = Carattere di more, 6 = Modalità evoluzione
    gameSettings[0] = 1;
    gameSettings[1] = 20;
    gameSettings[4] = 48; // 0
    gameSettings[5] = 46; // .
    gameSettings[6] = 1; // .
    
    cout << "---------- GAME OF LIFE ----------" << endl;
    cout << "          by  FO STUDIOS          " << endl;
    cout << "--------- Copyright 2021 ---------" << endl << endl;

    getLanguage();
    bool restart;
    do {
        restart = false;
        printText("\n[WARNING] Set shell in fullscreen.\n\nGame of life is game created by the matematician John Conway in 1970. Cell's evolution is based on simple rules.\n\n", "\n[ATTENZIONE] Impostare in tutto schermo il terminale!\n\nIl gioco della vita e\' un gioco inventato dal matematico John Conway nel 1970. Il suo funzionamento e\' basato su cellule che evolvono in base a semplici regole.\n\n");
        
        delay(1);
        
        gM = gameMode();
        if (!gM) { // Modalità scoperta
            gameSettings[2] = 0;
            printText("\n\nGood choice, let's start discovering the most famous patterns!\n","\n\nOttima scelta, partiamo subito alla scoperta dei pattern che hanno rivoluzionato il gioco della vita!\n");
            gameSettings[3] = patternSelection();
        }
        else { // Modalità gioco
            gameSettings[2] = 1;
            printText("\n\nGood choice, have fun!\n","\n\nOttima scelta! Buon divertimento!\n");
        }
        cout << endl << endl;
        gameSettings[1] = matrixDim();
        cout << endl ;
        
        setGameSettings(gameSettings);
        
        fillMatrix(gameSettings[1],world);
        
        if (!gM) {
            generatePattern(gameSettings, world);
        }
        else {
            printText("--- WORLD CONFIGURATION ---\n", "--- CONFIGURA MONDO ---\n");
            int end = 1;
            do {
                int x, y;
                char carattereDivisorio;
                printCartesianMatrix(gameSettings, world);
                do {
                    printText("Type 0x0 to finish the configuration.\n", "Digitare 0x0 per concludere configurazione.\n");
                    printText("Insert the coordinates of the cell which you want to change status: (X:Y)\n-> ", "Inserire le coordinate della cella di cui si deve cambiare lo stato: (X;Y)\n-> ");
                    cin >> x >> carattereDivisorio >> y;
                    if (x==0 && y==0 && (carattereDivisorio=='x'||carattereDivisorio=='X')) {
                        end=0;
                        break;
                    }
                    if(x-1<0 || y-1<0 || x-1>gameSettings[1] || y-1>gameSettings[1]) {
                        printText("[ERROR] Insert values between 1 and ", "[ERRORE] Inserire valori compresi tra 1 e ");
                        cout << gameSettings[1]+1 << "." << endl;
                    }
                    else {
                        if(world[y-1][x-1]) {
                            world[y-1][x-1] = false;
                        }
                        else {
                            world[y-1][x-1] = true;
                        }
                        break;
                    }
                } while(true);
            } while(end);
            // Imposta celle di vita di base
        }
        
        int evolution = 0;
        
        do {
            evolution++;
            printCycle(evolution, gameSettings[1]);
            printMatrix(gameSettings,world);
            bool newWorld[100][100];
            copyMatrix(world, newWorld);
            for (int i=0; i < gameSettings[1]; i++) {
                for (int j=0; j < gameSettings[1]; j++) {
                    int nearCell = neighborsCell(i, j, world);
                    if (nearCell>3 || nearCell<2) {
                        newWorld[i][j] = false;
                    }
                    else if (nearCell==3) {
                        newWorld[i][j] = true;
                    }
                }
            }
            copyMatrix(newWorld, world);
            
            if (gameSettings[6]==1) {
                delay(gameSettings[0]);
            }
            else {
                if(!wait()) {
                    return 0;
                }
            }
        } while(cellStillAlive(gameSettings[1],world)); // ci sono celle vive
        
        printText(" ", "Non c'e\' piu\' vita nel mondo!\n[1] Ricomincia\n[2] Chiudi\n[3] AIUTO\n-> ");
        switch (askValue(1, 3)) {
            case 1:
                restart = true;
                cout << endl << endl << endl;
                break;
            case 2:
                restart = false;
                cout << endl << endl << endl;
                break;
            default:
                break;
        }
    } while(restart);
    
    printText(" ", "Chiusura in corso...");
    
    return 0;
}
</code>
		</pre>
		<br/>
		<br/>

		<br/>
		<br/>
		<a name="inputFunctions.hpp"></a>
		<hr>
		<h3>
			INPUTFUNCTIONS.HPP
		</h3>
		<pre>
			<code class="language-cpp">
#ifndef inputFunctions_hpp
#define inputFunctions_hpp

#include "stdio.h"

int matrixDim(); // Ritorna la dimensione della matrice.

bool gameMode(); // True: Modalità gioco | False: Modalità scoperta

bool insertionMode(); // Ritorna true se la modlitità d'inserimento scelta è quella manuale, false se è automatica.

int patternSelection(); // Ritorna valore del pattern predefinito scelto.

void setGameSettings(int settings[]); // Imposta impostazioni della partita.

int getChar(); // Restitutisce valore ASCII del carattere inserito da utente.

#endif /* inputFunctions_hpp */
			</code>
		</pre>


		<br/>
		<br/>
		<a name="outputFunctions.hpp"></a>
		<hr>
		<h3>
			OUTPUTFUNCTIONS.HPP
		</h3>
		<pre>
			<code class="language-cpp">
#ifndef outputFunctions_hpp
#define outputFunctions_hpp

#include "stdio.h"

void printSettings(int settings[]);

void printMatrix(int settings[], bool world[][100]);

void printCartesianMatrix(int settings[], bool world[][100]);

void printCycle(int cycle, int worldDim);
#endif /* outputFunctions_hpp */
			</code>
		</pre>


		<br/>
		<br/>
		<a name="languageGestion.hpp"></a>
		<hr>
		<h3>
			LANGUAGEGESTION.HPP
		</h3>
		<pre>
			<code class="language-cpp">
#ifndef languageGestion_hpp
#define languageGestion_hpp

#include "stdio.h"
#include "iostream"

using namespace std;

void getLanguage(); // Imposta indice della lingua scelta.

int choosedLanguage(); // Ritorna valore di "language"

bool setLanguage(int languageIndex); // Cambia valore di "language"

void printText(string english, string italiano); // Stampa testo

#endif /* languageGestion_hpp */
			</code>
		</pre>


		<br/>
		<br/>
		<a name="systemFunctions.hpp"></a>
		<hr>
		<h3>
			SYSTEMFUNCTIONS.HPP
		</h3>
		<pre>
			<code class="language-cpp">
#ifndef systemFunctions_hpp
#define systemFunctions_hpp

#include "stdio.h"

bool checkValue(int min, int max, int input); // Controlla valore inserito

int askValue(int min, int max);

void delay(int second);

bool wait();
#endif /* systemFunctions_hpp */
			</code>
		</pre>


		<br/>
		<br/>
		<a name="automaticGenerationFunctions.hpp"></a>
		<hr>
		<h3>
			AUTOMATICGENERATIONSFUNCTIONS.HPP
		</h3>
		<pre>
			<code class="language-cpp">
#ifndef automaticGenerationFunctions_hpp
#define automaticGenerationFunctions_hpp

#include "stdio.h"

void fillMatrix(int dim, bool world[][100]);

void generatePattern(int settings[], bool world[][100]);

void copyMatrix(bool matrixOne[][100], bool matrixTwo[][100]);

#endif /* automaticGenerationFunctions_hpp */
			</code>
		</pre>


		<br/>
		<br/>
		<a name="lifeAndWorldGestion.hpp"></a>
		<hr>
		<h3>
			LIFEANDWORLDGESTION.HPP
		</h3>
		<pre>
			<code class="language-cpp">
#ifndef lifeAndWorldGestion_hpp
#define lifeAndWorldGestion_hpp

#include "stdio.h"

bool cellStillAlive(int dim, bool world[][100]);

void printWorld();

int neighborsCell(int cellX, int cellY, bool world[][100]);

#endif /* lifeAndWorldGestion_hpp */
			</code>
		</pre>


		<a name="inputFunctions.cpp"></a>
		<hr>
		<h3>
			INPUTFUNCTIONS.CPP
		</h3>
		<pre>
			<code class="language-cpp">
#include "inputFunctions.hpp"
#include "languageGestion.hpp"
#include "systemFunctions.hpp"
#include "outputFunctions.hpp"
#include "iostream"

using namespace std;

// Ritorna la dimensione della matrice.
int matrixDim() {
    int input = -1;
    do {
        printText("Select world's dimension:\n[1] 10\n[2] 25\n[3] 50\n[4] 100\n[5] Other\n[6] HELP\n-> ", "Selezionare la dimensione della matrice: \n[1] 10\n[2] 25\n[3] 50\n[4] 100\n[5] Altro\n[6] AIUTO\n-> ");
        input = askValue(1, 6);
        switch (input) {
            case 1: // 10
                printText("Setted size: 10", "Dimensione impostata: 10");
                cout << endl;
                return 10;
                break;
            case 2: // 25
                printText("Setted size: 25", "Dimensione impostata: 25");
                cout << endl;
                return 25;
                break;
            case 3: // 50
                printText("Setted size: 50", "Dimensione impostata: 50");
                cout << endl;
                return 50;
                break;
            case 4: // 100
                printText("Setted size: 100", "Dimensione impostata: 100");
                cout << endl;
                return 50;
                break;
            case 5: // Aiuto
                printText("Enter world's dimension:\n", "Inserire le dimensioni del mondo:\n-> ");
                return askValue(10, 100);
                break;
            case 6: // Aiuto
                printText("[HELP] Enter world's dimenions. Smaller values create smaller worlds, while bigger values create bigger worlds.\n", "[AIUTO] Inserire le dimensioni del mondo. Valori piccoli crearanno mondi piu\' ristretti mentre, valori alti generanno mondo piu\' grandi e longevi.\n");

                input =-1;
                break;
            default:
                break;
        }
    } while(input-=1);
    return 0; // Return mai raggiunto ma obbligatorio.
}

bool gameMode() {
    int input = -1;
    do {
        printText("Select game mode:\n[1] Discovery\n[2] Game\n[3] HELP\n-> ", "Selezionare la modalita\' di gioco:\n[1] Scoperta\n[2] Passatempo\n[3] AIUTO\n-> ");
        input = askValue(1, 3);
        switch (input) {
            case 1: // SCOPERTA
                printText("Selected mode: DISCOVERY", "Modalità selezionata: SCOPERTA");
                cout << endl;
                return false;
                break;
            case 2: // GIOCO
                printText("Selected mode: GAME", "Modalità selezionata: PASSATEMPO");
                cout << endl;
                return true;
                break;
            case 3: // Aiuto
                printText("","--- AIUTO ---\nSCOPERTA: del gioco della vita sono sicuramente famosi i pattern, particolari forme geometriche che vivono infinitamente. Grazia a questa modalità avrai modo di scoprirli.\nPASSATEMTO: un ottimo modo per allenare il proprio cervello! In questa modalità dovrai mettere accendere i tuoi neuroni e scoprire un pattern che possa durare il più a lungo possibile.\n\n");
                input =-1;
                break;
            default:
                printText(" ", "[ERRORE] Inserire un valore compreso tra 1 e 3.\n");
                input =-1;
                break;
        }
    } while(input-=1);
    return true; // Return mai raggiunto.
}

// Ritorna true se la modlitità d'inserimento scelta è quella manuale, false se è automatica.
bool insertionMode() {
    int input = -1;
    do {
        printText("Select imput mode:\n[1] Automatic\n[2] Manual\n[3] HELP\n-> ", "Selezionare la modalita\' d'inserimento:\n[1] Automatica\n[2] Manuale\n[3] AIUTO\n-> ");
        input = askValue(1, 3);
        switch (input) {
            case 1:
                printText("Selected pattern: BOAT\n Good Choice! Did you know that this pattern was discovered in 1970 by JHC Group?", "Pattern selezionato: BOAT\nBella scelta! Sapevi che questo pattern fu scoperto nel 1970 dal JHC Group? Questo gruppo da decenni studia questo meraviglioso gioco!\n");
                return 1;
            case 2:
                printText("Selected pattern: LOAF\n What a gran pattern! This one this pattern was discovered in 1970 by JHC Group, many compare it to a heart <3", "Pattern selezionato: LOAF\nChe bel pattern! Quest'ultimo fu scoperto nel 1970 dal JHC Group e viene paragonato da alcuni a un cuore <3!\n");
                return 2;
            case 3: // Aiuto
                cout << "[AIUTO] Selezionare la modalità desiderata per la generazione della prima cella vitale. La modalita\' AUTOMATICA (1) genera automaticamente le celle di vita. Invece, con la modalita\' MANUALE (2) sara\' l'utente, mediante lettura delle coordinate, a dover scegliere la posizione della prima cella vitale." << endl;
                input =-1;
                break;
            default:
                input =-1;
                break;
        }
    } while(input-=1);
    return true; // Return mai raggiunto.
}

int patternSelection() {
    int input = -1;
    do {
        printText("Select the pattern category to add:\n[1] Static\n[2] Active\n[3] Dynamic\n[4] HELP\n-> ", "Selezionare la categoria di pattern da aggiungere:\n[1] Statico\n[2] Attivo\n[3] Dinamico\n[4] AIUTO\n-> ");
        input = askValue(1, 4);
        switch (input) {
            case 1: // Statico
                do {
                    printText("\nSelect the pattern to add:\n[1] Boat\n[2] Loaf\n[3] HELP\n-> ", "\nSelezionare il pattern da aggiungere:\n[1] Boat\n[2] Loaf\n[3] AIUTO\n-> ");
                    input = askValue(1, 4);
                    switch (input) {
                        case 1:
                            printText("Selected pattern: BOAT", "Pattern selezionato: BOAT\nBella scelta! Sapevi che questo pattern fu scoperto nel 1970 dal JHC Group? Questo gruppo da decenni studia questo meraviglioso gioco!\n");
                            return 1;
                        case 2:
                            printText("Selected pattern: LOAF", "Pattern selezionato: LOAF\nChe bel pattern! Quest'ultimo fu scoperto nel 1970 dal JHC Group e viene paragonato da alcuni a un cuore!\n");
                            return 2;
                        case 3:
                            printText("--- HELP ---\n. . . . .\n. O O . .\n. O . O .\n. . O . .\n. . . . .\n  BOAT  \n\n. . . . . .\n. . O O . .\n. O . . O .\n. . O . O .\n. . . O . .\n. . . . . .\n   LOAF   \n\n", "--- AIUTO ---\n. . . . .\n. O O . .\n. O . O .\n. . O . .\n. . . . .\n  BOAT  \n\n. . . . . .\n. . O O . .\n. O . . O .\n. . O . O .\n. . . O . .\n. . . . . .\n   LOAF   \n\n");
                            input = -1;
                        default:
                            break;
                    }
                } while (input==-1);
                break;
            case 2: // ATTIVO
                do {
                    printText("Select the pattern to add:\n[1] Blinker\n[2] Toad\n[3] Beacon\n[4] HELP\n-> ", "Selezionare il pattern da aggiungere:\n[1] Blinker\n[2] Toad\n[3] Beacon\n[4] AIUTO\n-> ");
                    input = askValue(1, 4);
                    switch (input) {
                        case 1:
                            printText("Selected Pattern: BLINKER\nGood Choice! This pattern io one of the most famous an it was discovered on march 1970 John Conway.\n","Pattern selezionato: BLINKER\nOttima scelta! Questo pattern e\' uno dei piu\' famosi e venne scoperto nel lontano Marzo 1970 dall'ideatore del gioco, John Conway.\n");
                            return 3;
                        case 2:
                            printText("Selected pattern: TOAD, You have gran taste! Did you that this pattern was discovered bay the Mathematician Simon Norton?""Pattern selezionato: TOAD\nHai ottimi gusti! Tra l'altro, sapevi che questo pattern fu scoperto dal matematico Simon Norton?\n","Pattern selezionato: TOAD\nHai ottimi gusti! Tra l'altro, sapevi che questo pattern fu scoperto dal matematico Simon Norton?\n");
                            return 4;
                        case 3:
                            printText("Selected pattern: BEACON\n Good One! It was found by John Conway on march 1970. It is also known as DDO: diagonal on-off", "Pattern selezionato: BEACON\n Bel pattern! E\' stato trovato da John Conway nel Marzo 1970 ed'e\' anche conosciuto sotto il nome di DDO: diagonal on-off.\n");
                            return 5;
                        case 4:
                            printText("--- HELP ---\n. . . . .\n. . O . .\n. . O . .\n. . O . .\n. . O . .\n BLINKER\n\n. . . . . .\n. . . . . .\n. . O O O .\n. O O O . .\n. . . . . .\n. . . . . .\n   TOAD   \n\n. . . . . .\n. O O . . .\n. O . . . .\n. . . . O .\n. . . O O .\n. . . . . .\n  BEACON  \n\n", "--- AIUTO ---\n. . . . .\n. . O . .\n. . O . .\n. . O . .\n. . O . .\n BLINKER\n\n. . . . . .\n. . . . . .\n. . O O O .\n. O O O . .\n. . . . . .\n. . . . . .\n   TOAD   \n\n. . . . . .\n. O O . . .\n. O . . . .\n. . . . O .\n. . . O O .\n. . . . . .\n  BEACON  \n\n");
                            input = -1;
                        default:
                            break;
                    }
                } while (input==-1);
                break;
            case 3: // DINAMICO
                do {
                    printText("Select the pattern to add:\n[1] Glider\n[2] Light-Weight SpaceShip (LWSS)\n[3] HELP\n-> ", "Selezionare il pattern da aggiungere:\n[1] Glider\n[2] Light-Weight SpaceShip (LWSS)\n[3] AIUTO\n-> ");
                    input = askValue(1, 3);
                    switch (input) {
                        case 1:
                            printText("Selected pattern: GLIDER\n Glider is the most famous one! It was discovered 50 years ago by Richard K. Guy, a Mathematician and it can live forever (if it doesn't encounter obstacles)\n","Pattern selezionato: GLIDER\n Il pattern Glider e\' sicuramente il piu\' famoso tra tutti! Fu scoperto 50 anni fa dal matematico Richard K. Guy e puo\' vivere all'infinito (se non incontra ostacoli)\n");
                            return 6;
                        case 2:
                            printText("Selected pattern: LIGHT-WEIGHT SPACESHIP (LWSS)\nGood choice! This pattern, also known as Small Fish, was discovered by John Conway, in 1970.\n","Pattern selezionato: LIGHT-WEIGHT SPACESHIP (LWSS)\nBella scelta! Questo pattern, anche conosciuto sotto il nome di Small Fish, fu scoperto dall'inventore del gioco, John Conway, nel 1970.\n");
                            return 7;
                        case 3:
                            printText("--- HELP ---\n. . . . .\n. . O . .\n. . . O .\n. O O O .\n. . . . .\n GLIDER\n\n. . . . . . .\n. . O . . O .\n. O . . . . .\n. O . . . O .\n. O O O O . .\n. . . . . . .\n    LWSS   \n\n", "--- AIUTO ---\n. . . . .\n. . O . .\n. . . O .\n. O O O .\n. . . . .\n GLIDER\n\n. . . . . . .\n. . O . . O .\n. O . . . . .\n. O . . . O .\n. O O O O . .\n. . . . . . .\n    LWSS   \n\n");
                            input = -1;
                        default:
                            break;
                    }
                } while (input==-1);
                break;
            case 4: // Aiuto
                printText("--- HELP ---\nSTATIC: static patterns are configurations that stay active eternaly but doesn't change.\nATTIVO: active configurations remain in the same position, but they change at every cycle while they return to the start position.\nDINAMICO: dynamic pattern evolve at every cycle, changing position.\n\n", "--- AIUTO ---\nSTATICO: i pattern statici sono configurazioni che rimangono attive eternamente ma che non subiscono cambiamenti a ogni ciclo.\nATTIVO: le configurazioni attive rimangono in posizioni fisse ma cambiano a ogni ciclo, fino a tornare nella posizione originale.\nDINAMICO: i pattern dinamici evolvono spostandosi all'interno del mondo.\n\n");
                input =-1;
                break;
            default:
                break;
        }
    } while(input==-1);
    return 0; // Return mai raggiunto ma obbligatorio.
}

void setGameSettings(int settings[]) {
    int input;
    do {
        printText("\n--- GAME SETTINGS ---\nSelect an option:\n[1] Use default settings\n[2] Change settings\n[3] HELP\n-> ", "\n--- IMPOSTAZIONI DI GIOCO ---\nSelezionare un'opzione:\n[1] Utilizzare impostazioni predefinite\n[2] Cambia impostazioni\n[3] AIUTO\n-> ");
        input = askValue(1, 3);
        switch (input) {
            case 1:
                return;
                break;
            case 2:
                do {
                    printText("Select setting to change:\n[1] Delay time\n[2] World's size\n[3] Advanced settings\n[4] HELP\n-> ", "Selezionare l'impostazione da cambiare:\n[1] Tempo di pausa\n[2] Dimensioni mondo\n[3] Impostazioni avanzate\n[4] AIUTO\n-> ");
                    input = askValue(1, 4);
                    switch (input) {
                        case 1: {
                            bool c=false;
                            do {
                                printText("Enter delay time between evolutions (in seconds):\n-> ", "Inserire la duranta di pausa tra ogni evoluzione (in secondi):\n-> ");
                                settings[0] = askValue(0, 60);
                                if (settings[0]<1) {
                                    printText("[WARNING] Short delay time can cause efficiency problems.\n[1] Confirm inserted time\n[2] Enter the new value\n-> ", "[AVVERTIMENTO] Tempi relativamente piccoli possono causare problemi d'efficenza.\n[1] Conferma tempo inserito\n[2] Inserire nuovo valore\n-> ");
                                    switch (askValue(1, 2)) {
                                        case 1:
                                            c=false;
                                            break;
                                        case 2:
                                            c=true;
                                            break;
                                        default:
                                            break;
                                    }
                                }
                            } while(c);
                            break;
                        }
                        case 2:
                            printText("Enter world dimensions:\n-> ", "Inserire le dimensioni del mondo:\n-> ");
                            settings[1] = askValue(10, 100);
                            break;
                        case 3:
                            printText("Select the setting which you want to change:\n[1] Life Character\n[2] Death Character\n[3] Evolution mode\n[4] HELP\n-> ", "Selezionare l'impostazione da cambiare:\n[1] Carattere di vita\n[2] Carattere di morte\n[3] Modalita\' d'evoluzione\n[4] AIUTO\n-> ");
                            switch (askValue(1, 4)) {
                                case 1:
                                    settings[4] = getChar();
                                    break;
                                case 2:
                                    settings[5] = getChar();
                                    break;
                                case 3:
                                    printText("Select an Option:\n", "Selezionare un'opzione:\n");
                                    if (settings[6]) {
                                        printText("[1] Change to: manual evolution\n", "[1] Cambia a: evoluzione manuale\n");
                                    }
                                    else {
                                        printText("[1] Change to: Automatic evolution", "[1] Cambia a: evoluzione automatica\n");
                                    }
                                    printText("[2] Cancel\n-> ", "[2] Annulla\n-> ");
                                    switch (askValue(1, 2)) {
                                        case 1:
                                            if (settings[6]) {
                                                settings[6] = 0;
                                            }
                                            else {
                                                settings[6] = 1;
                                            }
                                            break;
                                        default:
                                            break;
                                    }
                                    break;
                                case 4:
                                    printText("--- HELP ---\nLIFE CHARACTER: change the character used to represent a life cell.\nDIED CHARACTER: change the character used to represent a died cell.\nEVOLUTION MODE: change evolution mode.\n\n", "--- AIUTO ---\nCARATTERE DI VITA: cambia il carattere utilizzato per rappresentare una cella di vita.\nCARATTERE DI MORTE: cambia il carattere utilizzato per rappresentare una cella morte.\nMODALITA\' EVOLUZIONE: cambia la modalita\' d'evoluzione.\n\n");
                                    input = -1;
                                default:
                                    break;
                            }
                            break;
                        case 4:
                            printText("--- HELP ---\nDELAY TIME: time, in seconds, passed between every evolution.\nWORLD DIMENSIONS: dimensions, in cell numbers, of world's grill.\nADVANCED SETTINGS: advanced setting of the party including world dimensions and gamemode.\n\n", "--- AIUTO ---\nTEMPO DI PAUSA: tempo, in secondi, trascorso tra ogni evoluzione.\nDIMENSIONI MONDO: dimensioni, in numero di celle, del della griglia del mondo.\nIMP. AVANZATE: impostazioni avanzate della partita tra cui le dimensioni del mondo e la modalita\' di gioco.\n\n");
                            input = -1;
                        default:
                            break;
                    }
                    printText("Check settings:\n", "Conferma impostazioni:\n");
                    printSettings(settings);
                    printText("[1] Confirm\n[2] Modify\n-> ", "[1] Conferma\n[2] Modifica\n-> ");
                    if (askValue(1, 2) == 2) {
                        input=-1;
                    }
                    else {
                        printText("Settings saved!\n", "Impostazioni salvate!\n");
                        return;
                    }
                } while (input==-1);
            case 3:
                printText("--- HELP ---\nDEFAULT SETTINGS: uses recommended settings.\nCHANGE SETTINGS: changes settings of the match including world dimensions and delay time between every evolution.\n", "--- AIUTO --\nIMP. PREDEFINITE: utilizza impostazioni consigliate.\nCAMBIA IMPOSTAZIONI: cambia le impostazioni della partita tra cui le dimensioni del mondo e il tempo di pausa tra ogni evoluzione.\n");
                input=-1;
            default:
                break;
        }
    } while (input==-1);
}

int getChar() {
    char character;
    printText("Enter the desired character:\n-> ", "Inserire il carattere desiderato:\n-> ");
    cin >> character;
    return int(character);
}
			</code>
		</pre>

		<br/>
		<br/>
<a name="outputFunctions.cpp"></a>
		<hr>
		<h3>
			OUTPUTFUNCTIONS.CPP
		</h3>
		<pre>
			<code class="language-cpp">
#include "outputFunctions.hpp"
#include "languageGestion.hpp"
#include "iostream"

using namespace std;

void printSettings(int settings[]) {
    printText("--- SETTINGS ---\n", "--- IMPOSTAZIONI ---\n");
    if (settings[6]) {
        printText("Delay time: ", "Tempo di pausa: ");
        cout << settings[0] << " sec." << endl;
    }
    printText("World's size: ", "Dimensioni mondo: ");
    cout << settings[1] << endl;
    printText("Gamemode: ", "Modalità di gioco: ");
    if (settings[2]) {
        printText("Game", "Passatempo");
    }
    else {
        printText("Discovery", "Scoperta");
    }
    cout << endl;
    printText("Evolution mode: ", "Modalità d'evoluzione: ");
    if (settings[6]) {
        printText("Automatic", "Automatica");
    }
    else {
        printText("Manual", "Manuale");
    }
    cout << endl;
    if (settings[3]==0) {
        printText("Selected pattern: ", "Pattern selezionato: ");
        switch (settings[3]) {
            case 1:
                cout << "BOAT" << endl;
                break;
            case 2:
                cout << "LOAF" << endl;
                break;
            case 3:
                cout << "BLINKER" << endl;
                break;
            case 4:
                cout << "TOAD" << endl;
                break;
            case 5:
                cout << "BEACON" << endl;
                break;
            case 6:
                cout << "GLIDER" << endl;
                break;
            case 7:
                cout << "LWSS" << endl;
                break;
            default:
                break;
        }
    }
    printText("Life character: ", "Carattere di vita: ");
    cout << char(settings[4]) << endl;
    printText("Died character: ", "Carattere di morte: ");
    cout << char(settings[5]) << endl;
}

void printMatrix(int settings[], bool world[][100]) {
    for (int i=0; i < settings[1]; i++) {
        for (int j=0; j < settings[1]; j++) {
            if (world[i][j]) {
                cout << " " << char(settings[4]);
            }
            else {
                cout << " " << char(settings[5]);
            }
        }
        cout << endl;
    }
}

void printCartesianMatrix(int settings[], bool world[][100]) {
    for (int i=0; i < settings[1]; i++) {
        if (i+1<=9) {
            cout << " " << i+1;
        }
        else {
            cout << i+1;
        }
        for (int j=0; j < settings[1]; j++) {
            if (world[i][j]) {
                cout << " " << char(settings[4]) << " ";
            }
            else {
                cout << " " << char(settings[5]) << " ";
            }
        }
        cout << endl;
    }
    cout << " ";
    for (int j=0; j < settings[1]; j++) {
        if (j+1<=9) {
            cout << "  " << j+1;
        }
        else {
            cout << " " << j+1;
        }
    }
    cout << endl;
}

void printCycle(int cycle, int worldDim) {
    int lessOne = 2;
    int lessTwo = 2;
    if(cycle>9 && cycle<=99) {
        lessOne = 2;
        lessTwo = 3;
    }
    else if(cycle>99 && cycle<=999) {
        lessOne = 3;
        lessTwo = 3;
    }
    else if(cycle>999 && cycle<=9999) {
        lessOne = 3;
        lessTwo = 4;
    }
    else if(cycle>9999) {
        lessOne = 4;
        lessTwo = 4;
    }
    cout << " ";
    for (int i=0; i < worldDim-lessOne; i++) {
        cout << "-";
    }
    cout << " " << cycle << " ";
    for (int i=0; i < worldDim-lessTwo; i++) {
        cout << "-";
    }
    cout << endl;
}
			</code>
		</pre>

		<br/>
		<br/>
		<a name="languageGestion.cpp"></a>
		<hr>
		<h3>
			LANGUAGEGESTION.CPP
		</h3>
		<pre>
			<code class="language-cpp">
#include "languageGestion.hpp"
#include "systemFunctions.hpp"
#include "iostream"

using namespace std;

int language;

// Ritorna valore di "language"
int choosedLanguage() {
    return language;
}

// Cambia valore di "language"
bool setLanguage(int languageIndex) {
    if (languageIndex<0||languageIndex>1) {
        return false;
    }
    else {
        language = languageIndex;
        return true;
    }
}

// Imposta lingua
void getLanguage() {
    cout << "Select language | Selezionare la lingua:" << endl << "[1] English     | Inglese" << endl << "[2] Italian     | Italiano" << endl << "-> ";
    language = askValue(1, 2);
}

// Stampa testo
void printText(string english, string italiano) {
    switch (language) {
        case 1:
            cout << english;
            break;
        default:
            cout << italiano;
            break;
    }
}
			</code>
		</pre>


		<br/>
		<br/>
		<a name="systemFunctions.cpp"></a>
		<hr>
		<h3>
			SYSTEMFUNCTIONS.CPP
		</h3>
		<pre>
			<code class="language-cpp">
#include "systemFunctions.hpp"
#include "languageGestion.hpp"
#include "iostream"
#include "time.h"
#include "chrono"

using namespace std;

bool checkValue(int min, int max, int input) {
    if (input<min || input>max) {
        return true;
    }
    return false;
}

int askValue(int min, int max) {
    int value;
    do {
        cin >> value;
        if(checkValue(min, max, value)) {
            switch (choosedLanguage()) {
                case 1:
                    cout << "[ERROR] Enter a value between" << min << " and " << "." << endl;
                    break;
                case 2:
                    cout << "[ERRORE] Inserire un valore compreso tra " << min << " e " << max << "." << endl;
                default:
                    break;
            }
        }
        else {
            return value;
        }
    } while (checkValue(min, max, value));
    return 0; // Return mai raggiunto.
}

void delay(int second) {
    time_t start = time(0);
    while( difftime(std::time(0), start) <=second);
}

bool wait() {
    do {
        printText("Select an option:\n[1] Continue\n[2] Stop\n[3] HELP\n-> ", "Selezionare un opzione:\n[1] Procedi\n[2] Stop\n[3] AIUTO\n-> ");
        switch (askValue(1, 3)) {
            case 1:
                return true;
                break;
            case 2:
                return false;
                break;
            case 3:
                printText("--- HELP ---\nCONTINUE: next evolution\nSTOP: end execution", "--- AIUTO ---\nPROCEDI: prossima evoluzione\nSTOP: ferma l'esecuzione del programma");
                break;
            default:
                break;
        }
    } while(true);
}
			</code>
		</pre>


		<br/>
		<br/>
		<a name="automaticGenerationFunctions.cpp"></a>
		<hr>
		<h3>
			AUTOMATICGENERATIONFUNCTIONS.CPP
		</h3>
		<pre>
			<code class="language-cpp">
#include "automaticGenerationFunctions.hpp"
#include "iostream"

using namespace std;

void fillMatrix(int dim, bool world[][100]) {
    for (int i=0; i<100; i++) {
        for (int j=0; j<100; j++) {
            world[i][j] = false;
        }
    }
}

void generatePattern(int settings[], bool world[][100]) {
    int center = settings[1]/2;
    switch (settings[3]) {
        case 1: {
            bool boatPattern[3][3] = {{true,true,false},{true,false,true},{false,true,false}};
            for (int i=-1; i<2; i++) {
                for (int j=-1; j<2; j++) {
                    world[center+i][center+j] = boatPattern[i+1][j+1];
                }
            }
            break;
        }
        case 2: {
            bool loafPattern[4][4] = {{false,true,true,false},{true,false,false,true},{false,true,false,true},{false,false,true,false}};
            for (int i=-1; i<3; i++) {
                for (int j=-1; j<3; j++) {
                    world[center+i][center+j] = loafPattern[i+1][j+1];
                }
            }
            break;
        }
        case 3: {
            bool blinkerPattern[3][1] = {{true},{true},{true}};
            for (int i=-1; i<2; i++) {
                for (int j=-1; j<0; j++) {
                    world[center+i][center+j] = blinkerPattern[i+1][j+1];
                }
            }
            break;
        }
        case 4: {
            bool toadPattern[4][4] = {{false,false,true,false},{true,false,false,true},{true,false,false,true},{false,true,false,false}};
            for (int i=-1; i<3; i++) {
                for (int j=-1; j<3; j++) {
                    world[center+i][center+j] = toadPattern[i+1][j+1];
                }
            }
            break;
        }
        case 5: {
            bool beaconPattern[4][4] = {{true,true,false,false},{true,true,false,false},{false,false,true,true},{false,false,true,true}};
            for (int i=-1; i<3; i++) {
                for (int j=-1; j<3; j++) {
                    world[center+i][center+j] = beaconPattern[i+1][j+1];
                }
            }
            break;
        }
        case 6: {
            bool gliderPatern[3][3] = {{true,false,true},{false,true,true},{false,true,false}};
            for (int i=-1; i<2; i++) {
                for (int j=-1; j<2; j++) {
                    world[center+i][center+j] = gliderPatern[i+1][j+1];
                }
            }
            break;
        }
        case 7: {
            bool lwssPattern[5][5] = {{true,false,false,true,false},{false,false,false,false,true},{true,false,false,false,true},{false,true,true,true,true}};
            for (int i=-1; i<4; i++) {
                for (int j=-1; j<4; j++) {
                    world[center+i][center+j] = lwssPattern[i+1][j+1];
                }
            }
            break;
        }
        default:
            break;
    }
}

void copyMatrix(bool matrixOne[][100], bool matrixTwo[][100]) {
    for (int i=0; i<100; i++) {
        for (int j=0; j<100; j++) {
            matrixTwo[i][j] = matrixOne[i][j];
        }
    }
}
			</code>
		</pre>


		<br/>
		<br/>
		<a name="lifeAndWorldGestion.cpp"></a>
		<hr>
		<h3>
			LIFEANDWORLDGESTION.CPP
		</h3>
		<pre>
			<code class="language-cpp">
#include "lifeAndWorldGestion.hpp"
#include "iostream"
#include "chrono"
#include "ctime"

using namespace std;

// -2 celle attorno muore.
// +3 celle attorno muore.

int neighborsCell(int cellX, int cellY, bool world[][100]) {
    int nearCells = 0;
        for (int i=-1; i<=1; i++) {
            for (int j=-1; j<=1; j++) {
                if (world[cellX+i][cellY+j]) {
                    if (i==0 && j==0) {
                    }
                    else {
                        nearCells++;
                    }
                }
            }
        }
        return nearCells;
}

bool cellStillAlive(int dim, bool world[][100]) {
    for (int i=0; i < dim; i++) {
        for (int j=0; j < dim; j++) {
            if (world[i][j]) {
                return true;
            }
        }
    }
    return false;
}
			</code>
		</pre>

		<p style="text-align: center; margin-top: 60px;"> <a class="white" style="color: black;" href="giocoDellaVita.html">← Torna indietro</a></p>

		<br/>
		<br/>
		<br/>
		<p style="text-align: center;"><img src="Immagini/Firma.png" height="75"></p>
		<h5 style="text-align: center; font-family: Avenir-Light">Realizzato col ❤️</h5>
		<h5 style="color: black; opacity: 0.25; font-size: 8px; text-align: center;">Progetto C++ completato assieme a Spahiu Fisnik nell'A.S. 2020/2021</h5>
	</body>
</html>